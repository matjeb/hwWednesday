Задача 1: Поиск подмассива с максимальной суммой (алгоритм Кадане)
Условие:
Дан массив целых чисел (возможно, содержащий отрицательные числа). Необходимо найти непрерывный подмассив (содержащий хотя бы один элемент), сумма элементов которого максимальна. Вернуть эту максимальную сумму.

Решение:
Используем динамическое программирование. Заведем две переменные: max_ending_here — максимальная сумма подмассива, оканчивающегося на текущей позиции, и max_so_far — глобальный максимум. Проходим по массиву один раз:

max_ending_here = max(элемент, max_ending_here + элемент)

max_so_far = max(max_so_far, max_ending_here)
По окончании возвращаем max_so_far.

using System;

public class MaxSubarraySum
{
    public static int FindMaxSum(int[] arr)
    {
        if (arr == null || arr.Length == 0)
            throw new ArgumentException("Массив не может быть пустым");
        
        int maxEndingHere = arr[0]; 
        int maxSoFar = arr[0];     
        
        for (int i = 1; i < arr.Length; i++)
        {

            maxEndingHere = Math.Max(arr[i], maxEndingHere + arr[i]);
            

            maxSoFar = Math.Max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    

    public static (int sum, int[] subarray) FindMaxSubarray(int[] arr)
    {
        if (arr == null || arr.Length == 0)
            throw new ArgumentException("Массив не может быть пустым");
        
        int maxEndingHere = arr[0];
        int maxSoFar = arr[0];
        int start = 0, end = 0, tempStart = 0;
        
        for (int i = 1; i < arr.Length; i++)
        {
            if (arr[i] > maxEndingHere + arr[i])
            {
                maxEndingHere = arr[i];
                tempStart = i;
            }
            else
            {
                maxEndingHere = maxEndingHere + arr[i];
            }
            
            if (maxEndingHere > maxSoFar)
            {
                maxSoFar = maxEndingHere;
                start = tempStart;
                end = i;
            }
        }

        int[] result = new int[end - start + 1];
        Array.Copy(arr, start, result, 0, result.Length);
        
        return (maxSoFar, result);
    }
}
Оценка сложности:

Временная сложность: O(n), где n — размер массива, так как выполняется один проход.

Пространственная сложность: O(1), используются только две вспомогательные переменные.

Обоснование:
Алгоритм Кадане основан на принципе оптимальности: максимальная сумма подмассива, оканчивающегося в позиции i, может быть либо сам элемент arr[i], либо сумма предыдущего максимума и текущего элемента. Это типичный пример однопроходного алгоритма с линейной сложностью. Оценка очевидна, но требует понимания, что каждый элемент обрабатывается один раз.

Задача 2: Поиск всех уникальных троек с нулевой суммой (3Sum)
Условие:
Дан массив целых чисел. Необходимо найти все уникальные тройки (a, b, c), такие что a + b + c = 0. Тройки не должны повторяться.

Решение:
Сортируем массив (это необходимо для использования метода двух указателей). Затем фиксируем один элемент (для i от 0 до n-3) и ищем два других с помощью двух указателей (left и right) в оставшейся части массива. Чтобы избежать дубликатов, пропускаем одинаковые элементы.

using System;
using System.Collections.Generic;

public class ThreeSumSolver
{
    public static IList<IList<int>> FindThreeSum(int[] nums)
    {
        List<IList<int>> result = new List<IList<int>>();
        
        if (nums == null || nums.Length < 3)
            return result;
        
        Array.Sort(nums);
        
        for (int i = 0; i < nums.Length - 2; i++)
        {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            
            int left = i + 1;
            int right = nums.Length - 1;
            
            while (left < right)
            {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum == 0)
                {
                    result.Add(new List<int> { nums[i], nums[left], nums[right] });
                    
                    int leftValue = nums[left];
                    while (left < right && nums[left] == leftValue)
                        left++;
                    
                    int rightValue = nums[right];
                    while (left < right && nums[right] == rightValue)
                        right--;
                }
                else if (sum < 0)
                {
                    left++;
                }
                else
                {
                    right--;
                }
            }
        }
        
        return result;
    }
}
Оценка сложности:

Сортировка занимает O(n log n).

Основной цикл с двумя указателями для каждого i выполняется O(n^2) в худшем случае (так как для каждого i мы проходим по оставшимся элементам).

Итоговая временная сложность: O(n^2).

Пространственная сложность: O(1) дополнительно (не считая памяти для результата, который может быть O(n^2) в худшем случае, но обычно не учитывается как дополнительная память алгоритма).

Обоснование:
После сортировки метод двух указателей позволяет для каждого фиксированного элемента i просмотреть оставшуюся часть массива за линейное время O(n). Так как внешний цикл выполняется O(n) раз, получаем O(n^2). Пропуск дубликатов не меняет асимптотику. Оценка требует анализа вложенных циклов и учета сортировки.

Краткое описание решений:

Задача 1 (Алгоритм Кадане)
Временная сложность: O(n) - один проход по массиву

Пространственная сложность: O(1) - только несколько переменных

Особенность: Работает даже с отрицательными числами

Задача 2 (3Sum)
Временная сложность: O(n²) - сортировка O(n log n) + два указателя O(n²)

Пространственная сложность: O(1) дополнительно (без учета результата)

Особенность: Использует сортировку и метод двух указателей для эффективного поиска
