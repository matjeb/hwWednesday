Задача 1: Поиск подмассива с максимальной суммой (алгоритм Кадане)
Условие:
Дан массив целых чисел (возможно, содержащий отрицательные числа). Необходимо найти непрерывный подмассив (содержащий хотя бы один элемент), сумма элементов которого максимальна. Вернуть эту максимальную сумму.

Решение:
Используем динамическое программирование. Заведем две переменные: max_ending_here — максимальная сумма подмассива, оканчивающегося на текущей позиции, и max_so_far — глобальный максимум. Проходим по массиву один раз:

max_ending_here = max(элемент, max_ending_here + элемент)

max_so_far = max(max_so_far, max_ending_here)
По окончании возвращаем max_so_far.

Псевдокод:

text
function maxSubarraySum(arr):
    max_ending_here = arr[0]
    max_so_far = arr[0]
    for i from 1 to len(arr)-1:
        max_ending_here = max(arr[i], max_ending_here + arr[i])
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
Оценка сложности:

Временная сложность: O(n), где n — размер массива, так как выполняется один проход.

Пространственная сложность: O(1), используются только две вспомогательные переменные.

Обоснование:
Алгоритм Кадане основан на принципе оптимальности: максимальная сумма подмассива, оканчивающегося в позиции i, может быть либо сам элемент arr[i], либо сумма предыдущего максимума и текущего элемента. Это типичный пример однопроходного алгоритма с линейной сложностью. Оценка очевидна, но требует понимания, что каждый элемент обрабатывается один раз.

Задача 2: Поиск всех уникальных троек с нулевой суммой (3Sum)
Условие:
Дан массив целых чисел. Необходимо найти все уникальные тройки (a, b, c), такие что a + b + c = 0. Тройки не должны повторяться.

Решение:
Сортируем массив (это необходимо для использования метода двух указателей). Затем фиксируем один элемент (для i от 0 до n-3) и ищем два других с помощью двух указателей (left и right) в оставшейся части массива. Чтобы избежать дубликатов, пропускаем одинаковые элементы.

Псевдокод:

text
function threeSum(arr):
    sort(arr)
    result = []
    for i from 0 to len(arr)-3:
        if i > 0 and arr[i] == arr[i-1]: continue
        left = i+1
        right = len(arr)-1
        while left < right:
            sum = arr[i] + arr[left] + arr[right]
            if sum == 0:
                result.append([arr[i], arr[left], arr[right]])
                left++
                while left < right and arr[left] == arr[left-1]: left++
                right--
                while left < right and arr[right] == arr[right+1]: right--
            else if sum < 0:
                left++
            else:
                right--
    return result
Оценка сложности:

Сортировка занимает O(n log n).

Основной цикл с двумя указателями для каждого i выполняется O(n^2) в худшем случае (так как для каждого i мы проходим по оставшимся элементам).

Итоговая временная сложность: O(n^2).

Пространственная сложность: O(1) дополнительно (не считая памяти для результата, который может быть O(n^2) в худшем случае, но обычно не учитывается как дополнительная память алгоритма).

Обоснование:
После сортировки метод двух указателей позволяет для каждого фиксированного элемента i просмотреть оставшуюся часть массива за линейное время O(n). Так как внешний цикл выполняется O(n) раз, получаем O(n^2). Пропуск дубликатов не меняет асимптотику. Оценка требует анализа вложенных циклов и учета сортировки.

